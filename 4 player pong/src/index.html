<!doctype html>
<html lang="hu">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>4-játékos Pong</title>
<style>
  body {
    margin:0;
    font-family:system-ui,Segoe UI,Roboto;
    background:#0b1220;
    color:#dfe7ff;
    display:flex;
    flex-direction:column;
    height:100vh;
    overflow:hidden;
  }
  header {
    padding:10px 16px;
    display:flex;
    gap:12px;
    align-items:center;
    background:#071025;
    box-shadow:0 2px 6px rgba(0,0,0,.6);
    z-index:10;
  }
  header h1 { font-size:16px; margin:0; }
  #status { margin-left:auto; font-size:13px; opacity:.9; }
  #game-wrap {
    flex:1;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
  }
  canvas {
    background:#0b2a3a;
    border:6px solid #022539;
    border-radius:8px;
    width:100vw;
    height:100vh;
    object-fit:contain;
  }
  #timer {
  font-size: 32px;
  font-weight: bold;
  color: #ff4444;
  margin-left: 10px;
  }
</style>
</head>
<body>
<header>
<header>
  <h1>4-játékos Pong</h1>
  <div id="status">
    WS: <span id="ws-state">csatlakozás...</span> |
    Idő: <span id="timer">60</span> mp
    <label for="volume-slider" style="margin-left:12px; font-size:13px;">Zene:</label>
    <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5">
  </div>
</header>
</header>

<div id="game-wrap">
  <canvas id="game"></canvas>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let wsUrl = "ws://raspberrypi.local:8080/4playerpong?type=display";
let socket = null;
let gameState = null;
let winnerTimeout = null;
let restartMessage = null;
let restartTimeout = null;
let scoreboardVisible = false;
let scoreboardTimeout = null;
// [hangfrekvencia, időtartam]
const marioTheme = [
  [659, 0.1], [659, 0.1], [0, 0.1], [659, 0.1], [0, 0.1], [523, 0.1], [659, 0.1], [0, 0.1], [784, 0.3]
];

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let masterGain = audioCtx.createGain();
masterGain.gain.value = 0.5; // alap hangerő
masterGain.connect(audioCtx.destination);

// hangerő slider
const volumeSlider = document.getElementById('volume-slider');
volumeSlider.addEventListener('input', (e) => {
  let val = parseFloat(e.target.value); // 0…1
  let gainValue = val === 0 ? 0 : Math.pow(val, 2); // 0.0–1.0
  masterGain.gain.setValueAtTime(gainValue, audioCtx.currentTime);
});

const colors = {1:"#75e0ff", 2:"#ffd57a", 3:"#9effa3", 4:"#ff9ecb"};
let scoreAnimations = {1:0,2:0,3:0,4:0}; // anim progresszió

function resizeCanvas() {
  const headerH = document.querySelector("header").offsetHeight;
  canvas.width = Math.max(400, window.innerWidth);
  canvas.height = Math.max(300, window.innerHeight - headerH - 10);
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ type: "displaySize", width: canvas.width, height: canvas.height }));
  }
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function tryConnect() {
  updateWSState('próbálkozás...');
  socket = new WebSocket(wsUrl);
  socket.onopen = () => {
    updateWSState('csatlakozva');
    socket.send(JSON.stringify({ type: "displaySize", width: canvas.width, height: canvas.height }));
  };
  socket.onerror = () => updateWSState('hiba');
  socket.onclose = () => {
    updateWSState('kapcsolat bontva, újracsatlakozás...');
    setTimeout(() => location.reload(), 1200);
  };
  socket.onmessage = (ev) => handleMessage(ev);
}
tryConnect();

function handleMessage(ev){
  const msg = JSON.parse(ev.data);
  if(msg.type==="state"){
    if(gameState && msg.scores){
      for(let i=1;i<=4;i++){
        if(msg.scores[i]!==gameState.scores[i]) scoreAnimations[i]=1.0;
      }
    }
    gameState = msg;
  }
  if(msg.type==="hit") sfxPaddleHit();
  if(msg.type==="reset") sfxStart();
  if(msg.type==="winner"){
    sfxScore();
    const winnerNames = {1:"Bal",2:"Jobb",3:"Felső",4:"Alsó"};
    scoreboardVisible = true;
    if (scoreboardTimeout) clearTimeout(scoreboardTimeout);

    scoreboardTimeout = setTimeout(() => { scoreboardVisible = false; }, 10000);
  }

  // ⏳ új funkció: idő kijelzése
  if(msg.type==="timer"){
    document.getElementById('timer').textContent = msg.time;
  }

  // pontszám reset
  if(msg.type==="resetScores"){
    if(gameState) gameState.scores = {1:0,2:0,3:0,4:0};
    sfxStart(); // hang resetnél

    restartMessage = "Újraindult a játék!";
    if(restartTimeout) clearTimeout(restartTimeout);
    restartTimeout = setTimeout(() => { restartMessage = null; }, 3000);
  }
}

function drawScoreboard(){
  if(!scoreboardVisible || !gameState?.scores) return;
  ctx.fillStyle = "rgba(0,0,0,0.8)";
  ctx.fillRect(canvas.width/2 - 250, canvas.height/2 - 200, 500, 500);

  ctx.font = "bold 36px sans-serif";
  ctx.textAlign = "center";
  ctx.fillStyle = "white";
  ctx.fillText("EREDMÉNYTÁBLA", canvas.width/2, canvas.height/2 - 120);

  const names = {1:"Bal",2:"Jobb",3:"Felső",4:"Alsó"};
  let i = 0;
  for (let id of [3,2,4,1]) { // sorrend: felső, jobb, alsó, bal
    ctx.fillStyle = colors[id];
    ctx.fillText(`${names[id]}: ${gameState.scores[id]}`, canvas.width/2, canvas.height/2 - 40 + i*60);
    i++;
  }

  const winnerId = Object.keys(gameState.scores).reduce((a,b)=> gameState.scores[a]>gameState.scores[b]?a:b);
  ctx.fillStyle = colors[winnerId];
  ctx.font = "bold 40px sans-serif";
  ctx.fillText(`${names[winnerId]} játékos nyert!`, canvas.width/2, canvas.height/2 + 220);
}


function drawScores(GOAL_MARGIN){
  if(!gameState?.scores) return;
  ctx.fillStyle="white";
  ctx.textAlign="center";
  for(let i=1;i<=4;i++){
    let scale = 1;
    if(scoreAnimations[i]>0){
      scale = 1 + 1.5 * scoreAnimations[i];  // sokkal nagyobb
      scoreAnimations[i]-=0.03;               // lassabb csökkenés
      if(scoreAnimations[i]<0) scoreAnimations[i]=0;
    }
    let x,y;
    if(i===1){x=GOAL_MARGIN-20; y=canvas.height/2+10;}
    if(i===2){x=canvas.width-GOAL_MARGIN+20; y=canvas.height/2+10;}
    if(i===3){x=canvas.width/2; y=GOAL_MARGIN-10;}
    if(i===4){x=canvas.width/2; y=canvas.height-GOAL_MARGIN+35;}
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(scale,scale);
    ctx.font="48px bold sans-serif";
    ctx.fillText(gameState.scores[i]??0,0,0);
    ctx.restore();
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const PADDLE_H = gameState?.paddles?.PADDLE_H ?? Math.floor(canvas.height*0.3);
  const PADDLE_W = gameState?.paddles?.PADDLE_W ?? Math.floor(canvas.width*0.18);
  const PADDLE_THICK = gameState?.paddles?.PADDLE_THICKNESS ?? Math.floor(Math.min(canvas.width,canvas.height)*0.035);
  const GOAL_MARGIN = 50;

  let p1y = gameState?.players?.[1]?.y ?? (canvas.height/2-PADDLE_H/2);
  let p2y = gameState?.players?.[2]?.y ?? (canvas.height/2-PADDLE_H/2);
  let p3x = gameState?.players?.[3]?.x ?? (canvas.width/2-PADDLE_W/2);
  let p4x = gameState?.players?.[4]?.x ?? (canvas.width/2-PADDLE_W/2);
  let bx = gameState?.ball?.x ?? canvas.width/2;
  let by = gameState?.ball?.y ?? canvas.height/2;

  const cornerSize = 120;
  ctx.strokeStyle="#fff";
  ctx.lineWidth=30;

  // sarkok
  [[0,0],[canvas.width,0],[0,canvas.height],[canvas.width,canvas.height]].forEach((c,i)=>{
    ctx.beginPath();
    if(i===0){ctx.moveTo(0,0); ctx.lineTo(cornerSize,0); ctx.moveTo(0,0); ctx.lineTo(0,cornerSize);}
    if(i===1){ctx.moveTo(canvas.width,0); ctx.lineTo(canvas.width-cornerSize,0); ctx.moveTo(canvas.width,0); ctx.lineTo(canvas.width,cornerSize);}
    if(i===2){ctx.moveTo(0,canvas.height); ctx.lineTo(cornerSize,canvas.height); ctx.moveTo(0,canvas.height); ctx.lineTo(0,canvas.height-cornerSize);}
    if(i===3){ctx.moveTo(canvas.width,canvas.height); ctx.lineTo(canvas.width-cornerSize,canvas.height); ctx.moveTo(canvas.width,canvas.height); ctx.lineTo(canvas.width,canvas.height-cornerSize);}
    ctx.stroke();
  });

  // paddlek + AI felirat
  const paddles = [
    {x:GOAL_MARGIN,y:p1y,w:PADDLE_THICK,h:PADDLE_H,role:1},
    {x:canvas.width-GOAL_MARGIN-PADDLE_THICK,y:p2y,w:PADDLE_THICK,h:PADDLE_H,role:2},
    {x:p3x,y:GOAL_MARGIN,w:PADDLE_W,h:PADDLE_THICK,role:3},
    {x:p4x,y:canvas.height-GOAL_MARGIN-PADDLE_THICK,w:PADDLE_W,h:PADDLE_THICK,role:4}
  ];

  paddles.forEach(p=>{
    ctx.fillStyle=colors[p.role];
    ctx.fillRect(p.x,p.y,p.w,p.h);
    if(gameState?.roles?.[p.role]==="AI"){
      ctx.fillStyle="#000";
      ctx.font="40px bold sans-serif"; // dupla méret
      ctx.textAlign="center";
      ctx.fillText("AI",p.x+p.w/2,p.y+p.h/2+6);
    }
  });

  // labda
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(bx,by,20,0,Math.PI*2);
  ctx.fill();

  // pontok animációval
  drawScores(GOAL_MARGIN);


  if(restartMessage){
    ctx.fillStyle="lime";
    ctx.font="bold 48px sans-serif";
    ctx.textAlign="center";
    ctx.fillText(restartMessage, canvas.width/2, canvas.height/2 + 80);
  }
  drawScoreboard();
  requestAnimationFrame(draw);
}

draw();

function updateWSState(s){ document.getElementById('ws-state').textContent=s; }

// placeholder hangok
function sfxPaddleHit(){ playMarioTheme(); }
function sfxStart(){  playTone(523, 0.3); }
function sfxScore(){ playTone(784, 0.4); }

function playTone(freq, duration) {
  const osc = audioCtx.createOscillator();
  osc.type = 'square';  // 8-bit / retro hang
  osc.frequency.value = freq;
  osc.connect(masterGain);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function playMarioTheme() {
  let t = 0;
  marioTheme.forEach(([freq, dur]) => {
    setTimeout(() => { if(freq>0) playTone(freq, dur); }, t*1000);
    t += dur;
  });
}

document.body.addEventListener('click', () => {
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
});
</script>
<button id="restartBtn">Restart Server</button>
<script>
  document.getElementById("restartBtn").addEventListener("click", () => {
    fetch("http://raspberrypi.local:3000/restart", { method: "POST" })
      .then(r => r.text())
      .then(msg => alert(msg))
      .catch(err => alert("Error: " + err));
  });
</script>
</body>

</body>
</html>
